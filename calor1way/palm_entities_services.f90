integer function if_ppalm_branches_instructions(id_branch,id_linesw)
!
!**** if_ppalm_branches_instructions : branches trigger
!
!     Purpose:
!     --------
!
!     File generated by PrePALM user: miguel 
!                               date: Tue Nov 15 16:39:03 CST 2016 
!     Don't edit this file!
!
!*--------------------------------------------------------------------------
!
!
   implicit none
!
   integer :: id_branch, id_linesw
!
   integer :: if_ppalm_b0_ctrlstruc
   integer :: if_ppalm_b1_ctrlstruc
!
   select case (id_branch) 
     case (0)
          if_ppalm_branches_instructions = if_ppalm_b0_ctrlstruc(id_linesw)
          return
     case (1)
          if_ppalm_branches_instructions = if_ppalm_b1_ctrlstruc(id_linesw)
          return
     case default
          if_ppalm_branches_instructions = 1
          return
   end select
end function if_ppalm_branches_instructions




module m_ppalm_entities_b0
  use palmlib
  use palm_user_param
  
!
!**** module m_ppalm_entities_b0 : private variable for branch b1
!
!     Purpose:
!     --------
!
!     File generated by PrePALM user: miguel 
!                               date: Tue Nov 15 16:39:03 CST 2016 
!     Don't edit this file!
!
!*--------------------------------------------------------------------------
!
   integer :: ig_bdon_branch_0 ! for no warning if the module is empty
   integer :: T

CONTAINS

SUBROUTINE palm_dump_branch_var()
    print *,'>>>======================= Branch 0 DUMP ================='
    print *,'>>> T = ',T

    print *,'>>>======================= END      DUMP ================='
END SUBROUTINE palm_dump_branch_var

end module m_ppalm_entities_b0



module m_ppalm_entities_b1
  use palmlib
  use palm_user_param
  
!
!**** module m_ppalm_entities_b1 : private variable for branch refin
!
!     Purpose:
!     --------
!
!     File generated by PrePALM user: miguel 
!                               date: Tue Nov 15 16:39:03 CST 2016 
!     Don't edit this file!
!
!*--------------------------------------------------------------------------
!
   integer :: ig_bdon_branch_1 ! for no warning if the module is empty
   integer :: Nmin = 6
   integer :: Nmax = 7
   integer :: n_nest = 3
   double precision :: time

CONTAINS

SUBROUTINE palm_dump_branch_var()
    print *,'>>>======================= Branch 1 DUMP ================='
    print *,'>>> Nmin = ',Nmin
    print *,'>>> Nmax = ',Nmax
    print *,'>>> n_nest = ',n_nest
    print *,'>>> time = ',time

    print *,'>>>======================= END      DUMP ================='
END SUBROUTINE palm_dump_branch_var

end module m_ppalm_entities_b1



integer function if_ppalm_b0_ctrlstruc(id_linesw)
!
!**** if_ppalm_b0_ctrlstruc : trigger instructions for F90 region
!
!     Purpose:
!     --------
!
!     File generated by PrePALM user: miguel 
!                               date: Tue Nov 15 16:39:03 CST 2016 
!     Don't edit this file!
!
!*--------------------------------------------------------------------------
!
 
   use palmlib
   use palm_user_param
   use m_ppalm_entities_b0
 
   implicit none
   include 'mpif.h'
!
   integer :: id_linesw
!
   integer :: il_ppalm_err, il_ppalm_err2, il_ppalm_time, il_ppalm_tag, il_ppalm_rank
   CHARACTER(LEN=PL_LNAME)       :: cl_ppalm_space, cl_ppalm_name
!
!  select the intructions to execute */
!
   select case (id_linesw) 
 
     case (1)
        T = 1
        if_ppalm_b0_ctrlstruc = 0
        return
 
     case (2)
     !Put object b1_put_1 
        cl_ppalm_space  = 'one_integer'
        cl_ppalm_name   = 'b1_put_1'
        il_ppalm_time   = PL_NO_TIME
        il_ppalm_tag    = PL_NO_TAG
        call MPI_Comm_rank(MPI_COMM_WORLD,il_ppalm_rank,il_ppalm_err)
        if (il_ppalm_rank .eq. 0) then 
           call PALM_Put(cl_ppalm_space, cl_ppalm_name, il_ppalm_time, il_ppalm_tag, T, il_ppalm_err)
        endif 
!        if (il_ppalm_err .ne. 0) then
!            print *,'Error in PALM_Put(one_integer,b1_put_1,PL_NO_TIME,PL_NO_TAG) '
!            il_ppalm_err2 = il_ppalm_err
!            call PALM_Error_explain(il_ppalm_err, il_ppalm_err)
!            call PALM_Abort(il_ppalm_err)
!        endif
 
        if_ppalm_b0_ctrlstruc = 0
        return
 
     case (3)
        T = T + ( 1 )
        if_ppalm_b0_ctrlstruc = 0
        return

     case default
        if_ppalm_b0_ctrlstruc = 1
        return

   end select

end function if_ppalm_b0_ctrlstruc




integer function if_ppalm_b1_ctrlstruc(id_linesw)
!
!**** if_ppalm_b1_ctrlstruc : trigger instructions for F90 region
!
!     Purpose:
!     --------
!
!     File generated by PrePALM user: miguel 
!                               date: Tue Nov 15 16:39:03 CST 2016 
!     Don't edit this file!
!
!*--------------------------------------------------------------------------
!
 
   use palmlib
   use palm_user_param
   use m_ppalm_entities_b1
 
   implicit none
   include 'mpif.h'
!
   integer :: id_linesw
!
   integer :: il_ppalm_err, il_ppalm_err2, il_ppalm_time, il_ppalm_tag, il_ppalm_rank
   CHARACTER(LEN=PL_LNAME)       :: cl_ppalm_space, cl_ppalm_name
!
!  select the intructions to execute */
!
   select case (id_linesw) 
 
     case (4)
     !Put object refin_put_2 
        cl_ppalm_space  = 'one_integer'
        cl_ppalm_name   = 'refin_put_2'
        il_ppalm_time   = PL_NO_TIME
        il_ppalm_tag    = PL_NO_TAG
        call MPI_Comm_rank(MPI_COMM_WORLD,il_ppalm_rank,il_ppalm_err)
        if (il_ppalm_rank .eq. 0) then 
           call PALM_Put(cl_ppalm_space, cl_ppalm_name, il_ppalm_time, il_ppalm_tag, Nmin, il_ppalm_err)
        endif 
!        if (il_ppalm_err .ne. 0) then
!            print *,'Error in PALM_Put(one_integer,refin_put_2,PL_NO_TIME,PL_NO_TAG) '
!            il_ppalm_err2 = il_ppalm_err
!            call PALM_Error_explain(il_ppalm_err, il_ppalm_err)
!            call PALM_Abort(il_ppalm_err)
!        endif
 
        if_ppalm_b1_ctrlstruc = 0
        return
 
     case (5)
     !Put object refin_put_3 
        cl_ppalm_space  = 'one_integer'
        cl_ppalm_name   = 'refin_put_3'
        il_ppalm_time   = PL_NO_TIME
        il_ppalm_tag    = PL_NO_TAG
        call MPI_Comm_rank(MPI_COMM_WORLD,il_ppalm_rank,il_ppalm_err)
        if (il_ppalm_rank .eq. 0) then 
           call PALM_Put(cl_ppalm_space, cl_ppalm_name, il_ppalm_time, il_ppalm_tag, Nmax, il_ppalm_err)
        endif 
!        if (il_ppalm_err .ne. 0) then
!            print *,'Error in PALM_Put(one_integer,refin_put_3,PL_NO_TIME,PL_NO_TAG) '
!            il_ppalm_err2 = il_ppalm_err
!            call PALM_Error_explain(il_ppalm_err, il_ppalm_err)
!            call PALM_Abort(il_ppalm_err)
!        endif
 
        if_ppalm_b1_ctrlstruc = 0
        return
 
     case (6)
     !Put object refin_put_4 
        cl_ppalm_space  = 'one_integer'
        cl_ppalm_name   = 'refin_put_4'
        il_ppalm_time   = PL_NO_TIME
        il_ppalm_tag    = PL_NO_TAG
        call MPI_Comm_rank(MPI_COMM_WORLD,il_ppalm_rank,il_ppalm_err)
        if (il_ppalm_rank .eq. 0) then 
           call PALM_Put(cl_ppalm_space, cl_ppalm_name, il_ppalm_time, il_ppalm_tag, n_nest, il_ppalm_err)
        endif 
!        if (il_ppalm_err .ne. 0) then
!            print *,'Error in PALM_Put(one_integer,refin_put_4,PL_NO_TIME,PL_NO_TAG) '
!            il_ppalm_err2 = il_ppalm_err
!            call PALM_Error_explain(il_ppalm_err, il_ppalm_err)
!            call PALM_Abort(il_ppalm_err)
!        endif
 
        if_ppalm_b1_ctrlstruc = 0
        return

     case default
        if_ppalm_b1_ctrlstruc = 1
        return

   end select

end function if_ppalm_b1_ctrlstruc




integer function if_ppalm_ctrlstruc(id_branch,id_func,id_value)
!  branch trigger 
!
   implicit none
!
   integer :: id_branch, id_func,id_value
!
   integer :: if_ppalm_0_br_serv
   integer :: if_ppalm_1_br_serv
!
   select case (id_branch) 
     case (0)
          if_ppalm_ctrlstruc = if_ppalm_0_br_serv(id_func,id_value)
          return
     case (1)
          if_ppalm_ctrlstruc = if_ppalm_1_br_serv(id_func,id_value)
          return
     case default
          if_ppalm_ctrlstruc = 1
          return
   end select
end function if_ppalm_ctrlstruc




integer function if_ppalm_0_br_serv(id_func,id_value)
!
!**** if_ppalm_0_br_serv : 
!
!     Purpose:
!     --------
!
!     File generated by PrePALM user: miguel 
!                               date: Tue Nov 15 16:39:03 CST 2016 
!     Don't edit this file!
!
!*--------------------------------------------------------------------------
!
 
   use m_ppalm_entities_b0
   use palm_user_param
 
   implicit none
!
   integer :: id_func,id_value
   logical :: ll_test
!
!  select the code to execute */
!
   if_ppalm_0_br_serv = 0
!
   select case (id_func) 
! case to evaluate the begin of a DO loop 
     case (1)
        id_value = 1
        return
! case to evaluate the end of a DO loop 
     case (2)
        id_value = 6
        return
! case to evaluate the increment of a DO loop 
     case (3)
        id_value = 1
        return
! case to evaluate a IF condition 
     case (4)
        ll_test = ( T < 6 )
        if (ll_test) then 
           id_value = 1
        else
           id_value = 0
        endif
        return
     case default
        if_ppalm_0_br_serv = 1
        return
   end select
end function if_ppalm_0_br_serv




integer function if_ppalm_1_br_serv(id_func,id_value)
!
!**** if_ppalm_1_br_serv : 
!
!     Purpose:
!     --------
!
!     File generated by PrePALM user: miguel 
!                               date: Tue Nov 15 16:39:03 CST 2016 
!     Don't edit this file!
!
!*--------------------------------------------------------------------------
!
 
   use m_ppalm_entities_b1
   use palm_user_param
 
   implicit none
!
   integer :: id_func,id_value
   logical :: ll_test
!
!  select the code to execute */
!
   if_ppalm_1_br_serv = 0
!
   select case (id_func) 
     case default
        if_ppalm_1_br_serv = 1
        return
   end select
end function if_ppalm_1_br_serv




integer function if_ppalm_exchange_module(id_branch,id_way,id_bloc,id_proc)
!
!**** if_palm_exchange_module : branches trigger for send/recv module
!
!     Purpose:
!     --------
!
!     File generated by PrePALM user: miguel 
!                               date: Tue Nov 15 16:39:03 CST 2016 
!     Don't edit this file!
!
!*--------------------------------------------------------------------------
!
!
   implicit none
!
   integer :: id_way,id_branch,id_bloc,id_proc
!                     id_way = 1 (IP_SEND) send module whith current values of variables
!                     id_way = 2 (IP_RECV) recv module and setup variables
!
   integer :: if_ppalm_b0_exchange_module
   integer :: if_ppalm_b1_exchange_module
!
   if (id_way.ne.1.and.id_way.ne.2) then 
      if_ppalm_exchange_module = 1
      return
   endif
 
   select case (id_branch) 
     case (0)
          if_ppalm_exchange_module = if_ppalm_b0_exchange_module(id_way,id_bloc,id_proc)
          return
     case (1)
          if_ppalm_exchange_module = if_ppalm_b1_exchange_module(id_way,id_bloc,id_proc)
          return
     case default
          if_ppalm_exchange_module = 1
          return
   end select
end function if_ppalm_exchange_module




integer function if_ppalm_b0_exchange_module(id_way,id_bloc,id_proc)
!
!**** if_ppalm_b0_ctrlstruc : Send function for block/driver exchanges
!
!     Purpose:
!     --------
!
!     File generated by PrePALM user: miguel 
!                               date: Tue Nov 15 16:39:03 CST 2016 
!     Don't edit this file!
!
!*--------------------------------------------------------------------------
!
 
   use m_ppalm_entities_b0
 
   implicit none
   integer, parameter :: IP_PORT_ENT = 1
   integer :: id_way,id_bloc,id_proc
!                     id_way = 1 send module whith current values of variables
!                     id_way = 2 recv module and setup variables
   integer :: il_err
 
    integer, dimension(1) :: ila_mess
!
   if (id_way.eq.1) then
       ila_mess(1) = T

       call if_intermpisend(IP_PORT_ENT,id_bloc,ila_mess,1*KIND(ila_mess(1)),id_proc,1238,il_err)
   endif
 
   if (id_way.eq.2) then
       call if_intermpirecv(IP_PORT_ENT,id_bloc,ila_mess,1*KIND(ila_mess(1)),id_proc,1238,il_err)
       T = ila_mess(1) 

   endif
   if_ppalm_b0_exchange_module = 0
end function if_ppalm_b0_exchange_module




integer function if_ppalm_b1_exchange_module(id_way,id_bloc,id_proc)
!
!**** if_ppalm_b1_ctrlstruc : Send function for block/driver exchanges
!
!     Purpose:
!     --------
!
!     File generated by PrePALM user: miguel 
!                               date: Tue Nov 15 16:39:03 CST 2016 
!     Don't edit this file!
!
!*--------------------------------------------------------------------------
!
 
   use m_ppalm_entities_b1
 
   implicit none
   integer, parameter :: IP_PORT_ENT = 1
   integer :: id_way,id_bloc,id_proc
!                     id_way = 1 send module whith current values of variables
!                     id_way = 2 recv module and setup variables
   integer :: il_err
 
    integer, dimension(3) :: ila_mess
    double precision, dimension(1) :: dla_mess
!
   if (id_way.eq.1) then
       ila_mess(1) = Nmin
       ila_mess(2) = Nmax
       ila_mess(3) = n_nest
       dla_mess(1) = time

       call if_intermpisend(IP_PORT_ENT,id_bloc,ila_mess,3*KIND(ila_mess(1)),id_proc,1238,il_err)
       call if_intermpisend(IP_PORT_ENT,id_bloc,dla_mess,1*KIND(dla_mess(1)),id_proc,1240,il_err)
   endif
 
   if (id_way.eq.2) then
       call if_intermpirecv(IP_PORT_ENT,id_bloc,ila_mess,3*KIND(ila_mess(1)),id_proc,1238,il_err)
       call if_intermpirecv(IP_PORT_ENT,id_bloc,dla_mess,1*KIND(dla_mess(1)),id_proc,1240,il_err)
       Nmin = ila_mess(1) 
       Nmax = ila_mess(2) 
       n_nest = ila_mess(3) 
       time = dla_mess(1)

   endif
   if_ppalm_b1_exchange_module = 0
end function if_ppalm_b1_exchange_module




integer function if_ppalm_nbproc_unit(id_branch,id_unit,id_flag,id_value)
!  branch trigger for unit's nbproc 
!
   implicit none
!
   integer :: id_branch, id_flag, id_unit,id_value
!
   integer :: if_ppalm_b0_nbproc_unit
   integer :: if_ppalm_b1_nbproc_unit
!
 
 
   select case (id_branch) 
     case (0)
          if_ppalm_nbproc_unit = if_ppalm_b0_nbproc_unit(id_unit,id_flag,id_value)
          return
     case (1)
          if_ppalm_nbproc_unit = if_ppalm_b1_nbproc_unit(id_unit,id_flag,id_value)
          return
     case default
          if_ppalm_nbproc_unit = 1
          return
   end select
end function if_ppalm_nbproc_unit




integer function if_ppalm_b0_nbproc_unit(id_unit,id_flag,id_value)
!
!**** if_ppalm_b0_nbproc_unit : 
!
!     Purpose:
!     --------
!
!     File generated by PrePALM user: miguel 
!                               date: Tue Nov 15 16:39:03 CST 2016 
!     Don't edit this file!
!
!*--------------------------------------------------------------------------
!
 
   use m_ppalm_entities_b0
   use palm_user_param
 
   implicit none
!
   integer :: id_unit,id_flag,id_value,il_maxi_proooc
   character(len=80) :: cl_nbproc
!
!
!  select the code to execute */
!
   if_ppalm_b0_nbproc_unit = 0
!
   select case (id_unit) 
          case (2)
!              main_condiciones
               call getenv('NBPROC_main_condiciones',cl_nbproc)
               if (cl_nbproc(1:3) .eq. '   ') then 
                   id_value = 1
!                   print *, '====> nb_proc affecte par defaul par prepalm a : ',id_value
               else
                    read (cl_nbproc,*) id_value
!                    print *, '====> nb_proc Lu dans la variable env :',id_value
               endif
               return
          case (3)
!              main_solver
               call getenv('NBPROC_main_solver',cl_nbproc)
               if (cl_nbproc(1:3) .eq. '   ') then 
                   id_value = 1
!                   print *, '====> nb_proc affecte par defaul par prepalm a : ',id_value
               else
                    read (cl_nbproc,*) id_value
!                    print *, '====> nb_proc Lu dans la variable env :',id_value
               endif
               return
          case default
               if_ppalm_b0_nbproc_unit = 1
               return
   end select
end function if_ppalm_b0_nbproc_unit
integer function if_ppalm_b1_nbproc_unit(id_unit,id_flag,id_value)
!
!**** if_ppalm_b1_nbproc_unit : 
!
!     Purpose:
!     --------
!
!     File generated by PrePALM user: miguel 
!                               date: Tue Nov 15 16:39:03 CST 2016 
!     Don't edit this file!
!
!*--------------------------------------------------------------------------
!
 
   use m_ppalm_entities_b1
   use palm_user_param
 
   implicit none
!
   integer :: id_unit,id_flag,id_value,il_maxi_proooc
   character(len=80) :: cl_nbproc
!
!
!  select the code to execute */
!
   if_ppalm_b1_nbproc_unit = 0
!
   select case (id_unit) 
          case (4)
!              main_solver2
               call getenv('NBPROC_main_solver2',cl_nbproc)
               if (cl_nbproc(1:3) .eq. '   ') then 
                   id_value = 1
!                   print *, '====> nb_proc affecte par defaul par prepalm a : ',id_value
               else
                    read (cl_nbproc,*) id_value
!                    print *, '====> nb_proc Lu dans la variable env :',id_value
               endif
               return
          case (5)
!              main_vecteur_print
               call getenv('NBPROC_main_vecteur_print',cl_nbproc)
               if (cl_nbproc(1:3) .eq. '   ') then 
                   id_value = 1
!                   print *, '====> nb_proc affecte par defaul par prepalm a : ',id_value
               else
                    read (cl_nbproc,*) id_value
!                    print *, '====> nb_proc Lu dans la variable env :',id_value
               endif
               return
          case default
               if_ppalm_b1_nbproc_unit = 1
               return
   end select
end function if_ppalm_b1_nbproc_unit


!***************************************************************
!
!
!          fonctions de service pour les fichiers 
!
!***************************************************************

integer function if_ppalm_puttofile(id_tube)
!  cette fonction retourne 0 ou 1 selon que le tube abouti ou non a un fichier
 
   implicit none
 
   integer :: id_tube, il_retour
 
   il_retour =0
 
   if_ppalm_puttofile = il_retour
end function if_ppalm_puttofile



subroutine ppalm_printtofile(id_index, id_tube, id_time, id_tag, id_rank, ida_obj,id_size, id_putdlrk)
!  trigger sur le numero de tube 
  integer :: id_tube, id_size, ida_obj, id_time, id_tag, id_rank, id_putdlrk
end subroutine ppalm_printtofile



integer function  if_ppalm_flnmw(id_tube,cla_formfile,id_time,id_tag,id_rank)
!  trigger sur le numero de tube 
   integer :: id_tube,  id_time, id_tag, id_rank
   character(LEN=256) :: cla_formfile
 
  if_ppalm_flnmw = -1
end function if_ppalm_flnmw


integer function if_ppalm_getfromfile(id_tube)
!  cette fonction retourne 0 ou 1 selon que le tube demare ou non d'un fichier
 
   implicit none
 
   integer :: id_tube, il_retour
 
   il_retour =0
 
   if_ppalm_getfromfile = il_retour
end function if_ppalm_getfromfile



subroutine ppalm_getfromfile(id_index, id_tube, id_time, id_tag, id_rank, ida_obj,id_size, id_putdlrk)
!  trigger sur le numero de tube 
  integer :: id_tube, id_size, ida_obj, id_time, id_tag, id_rank, id_putdlrk
end subroutine ppalm_getfromfile



integer function  if_ppalm_flnmr(id_tube,cla_formfile,id_time,id_tag,id_rank)
!  trigger sur le numero de tube 
   integer :: id_tube,  id_time, id_tag, id_rank
   character(LEN=256) :: cla_formfile
 
  if_ppalm_flnmr = -1
end function if_ppalm_flnmr


!***************************************************************
!          time & tag functions
!***************************************************************
integer function if_ppalm_timetag_search(id_numfunc,id_z_srctgtflag,id_time,id_tag,id_z_nb,ida_z_list,id_z_list_size)
   implicit none
 
   integer, intent(in)    :: id_numfunc,id_z_srctgtflag,id_time,id_tag,id_z_list_size
   integer, intent(inout) :: id_z_nb,ida_z_list(*)
 
   integer if_ppalm_timetag_search_0
 
   if_ppalm_timetag_search = -1
   id_z_nb = 0
 
   select case (id_numfunc) 
       case (0)
            if_ppalm_timetag_search =if_ppalm_timetag_search_0(id_z_srctgtflag,id_time,id_tag,id_z_nb,ida_z_list,id_z_list_size)
            return
   end select
end function if_ppalm_timetag_search


integer function if_ppalm_timetag_nb(id_numfunc)
   implicit none
 
   integer, intent(in)    :: id_numfunc
 
   integer if_ppalm_ppexp_nb_time_0
   integer if_ppalm_ppexp_nb_tag_0
 
   if_ppalm_timetag_nb = -1
 
   select case (id_numfunc) 
       case (0)
            if_ppalm_timetag_nb = if_ppalm_ppexp_nb_time_0() * if_ppalm_ppexp_nb_tag_0()
            return
   end select
end function if_ppalm_timetag_nb


integer function if_ppalm_time_nb(id_numfunc)
   implicit none
 
   integer, intent(in)    :: id_numfunc
 
   integer if_ppalm_ppexp_nb_time_0
 
   if_ppalm_time_nb = -1
 
   select case (id_numfunc) 
       case (0)
            if_ppalm_time_nb = if_ppalm_ppexp_nb_time_0()
            return
   end select
end function if_ppalm_time_nb


integer function if_ppalm_tag_nb(id_numfunc)
   implicit none
 
   integer, intent(in)    :: id_numfunc
 
   integer if_ppalm_ppexp_nb_tag_0
 
   if_ppalm_tag_nb = -1
 
   select case (id_numfunc) 
       case (0)
            if_ppalm_tag_nb = if_ppalm_ppexp_nb_tag_0()
            return
   end select
end function if_ppalm_tag_nb


integer function if_ppalm_give_timetag(id_numfunc,id_z_srctgtflag,id_lcommid,id_time,id_tag)
   implicit none
 
   integer, intent(in)    :: id_numfunc,id_z_srctgtflag,id_lcommid 
   integer                :: id_time,id_tag !out
 
   integer if_ppalm_give_timetag_0
 
   if_ppalm_give_timetag = -1
 
   select case (id_numfunc) 
       case (0)
            if_ppalm_give_timetag = if_ppalm_give_timetag_0(id_z_srctgtflag,id_lcommid,id_time,id_tag)
            return
   end select
end function if_ppalm_give_timetag


integer function if_ppalm_time_nbor(id_numfunc,id_time_in,id_nbor_inf_found,id_nbor_inf,id_nbor_sup_found,id_nbor_sup)
!  
!  Cette fonction permet de retourner les plus proches voisins pour le time dans un tube donne 
!  en entree 
!      id_numfunc  : identifiant de la fonction a appeler (donne dans le .pil) 
!      id_time_in  : time duquel on veut les plus proches voisins
!  en sortie 
!      id_nbor_inf_found : 0 ou 1 si un plus proche voisin inferieur a id_time_in est trouve
!      id_nbor_sup_found : 0 ou 1 si un plus proche voisin superieur a id_time_in est trouve
!      id_nbor_inf : plus proche voisin inferieur a id_time_in
!      id_nbor_sup : plus proche voisin superieur a id_time_in
!  
!  la valeur de retour de la fonction est -1 en cas de probleme et id_nbor_inf_found + 2*id_nbor_sup_found
!  sinon 
!  
   implicit none
!  
   integer, intent(in)    :: id_numfunc, id_time_in
   integer                :: id_nbor_inf,id_nbor_sup ! out
   integer                :: id_nbor_inf_found,id_nbor_sup_found ! out
 
   integer if_ppalm_time_nbor_0
 
   if_ppalm_time_nbor = -1
 
   select case (id_numfunc) 
       case (0)
            if_ppalm_time_nbor = if_ppalm_time_nbor_0(id_time_in,id_nbor_inf_found,id_nbor_inf,id_nbor_sup_found,id_nbor_sup)
            return
   end select
end function if_ppalm_time_nbor


 
integer function if_ppalm_time_nbor_0(id_time_in,id_nbor_inf_found,id_nbor_inf,id_nbor_sup_found,id_nbor_sup)
!  
   use palm_user_param
   use gen_palmdef_f
!  
   implicit none
   integer, intent(in)    :: id_time_in
   integer                :: id_nbor_inf,id_nbor_sup !out
   integer                :: id_nbor_inf_found,id_nbor_sup_found !out
 
   integer :: ib_ppalm_do
   integer :: i,o
!  
   id_nbor_inf_found = 0
   id_nbor_sup_found = 0
!expression PL_NO_TIME
  do ib_ppalm_do = PL_NO_TIME , PL_NO_TIME , 1
     if (ib_ppalm_do .le. id_time_in) then 
!       candidat plus proche voisin inf   
        if (id_nbor_inf_found .eq. 0) then 
            id_nbor_inf_found = 1 
            id_nbor_inf = ib_ppalm_do
        else 
            if (ib_ppalm_do .gt. id_nbor_inf) id_nbor_inf = ib_ppalm_do
        endif 
     endif 
!
     if (ib_ppalm_do .ge. id_time_in) then 
!       candidat plus proche voisin sup  
        if (id_nbor_sup_found .eq. 0) then 
            id_nbor_sup_found = 1 
            id_nbor_sup = ib_ppalm_do
        else 
            if (ib_ppalm_do .lt. id_nbor_sup) id_nbor_sup = ib_ppalm_do
        endif 
     endif 
  enddo 
! si la borne inf est egale au temps demande, on ramene la borne sup a la meme valeur
  if (id_nbor_inf.eq.id_time_in) then
            id_nbor_sup_found = 1 
            id_nbor_sup = id_nbor_inf
  endif 
!  print *,'demande :',id_time_in, ' bornes :', id_nbor_inf, id_nbor_sup 
  if_ppalm_time_nbor_0 = id_nbor_inf_found + 2*id_nbor_sup_found 
end function if_ppalm_time_nbor_0 
 
integer function if_ppalm_ppexp_time_0(id_z_srctgt,id_z_in,id_z_nb,ida_z_list,id_z_list_size)
!  
   use palm_user_param
!  
   implicit none
   integer, intent(in)    :: id_z_srctgt,id_z_in,id_z_list_size
   integer, intent(out)   :: id_z_nb,ida_z_list(*)
 
   integer :: il_z_nbtot,il_z_cpt,il_z_res,il_z_nb
!  
   integer if_ppalm_ppsexp_time_0_1
   il_z_cpt = 0
   id_z_nb  = 0
   if_ppalm_ppexp_time_0 = -1
  
   il_z_res = if_ppalm_ppsexp_time_0_1(id_z_srctgt,il_z_cpt,id_z_in,il_z_nb,ida_z_list(id_z_nb+1),il_z_nbtot,id_z_list_size)
   il_z_cpt = il_z_cpt + il_z_nbtot
   id_z_nb  = id_z_nb + il_z_nb
   if (id_z_nb.ne.0) if_ppalm_ppexp_time_0 = ida_z_list(1)
end function if_ppalm_ppexp_time_0 
 
 
integer function if_ppalm_ppexp_give_time_0(id_z_srctgt,id_num,id_val)
!  
   use palm_user_param
!  
   implicit none
   integer, intent(in)    :: id_z_srctgt,id_num
   integer, intent(out)   :: id_val
 
   integer :: il_z_nb,il_locnb
!  
   integer if_ppalm_ppsexp_givetime_0_1
   il_z_nb  = 0
   il_locnb  = 0
   if_ppalm_ppexp_give_time_0 = -1
  
   il_z_nb = il_z_nb+1
   if (il_z_nb.ge.id_num) then 
     if_ppalm_ppexp_give_time_0 = 1
     id_val = if_ppalm_ppsexp_givetime_0_1(id_z_srctgt,id_num-il_locnb)
     return
   endif 
   il_locnb = il_z_nb 
end function if_ppalm_ppexp_give_time_0


 
integer function if_ppalm_ppexp_nb_time_0()
   use palm_user_param
 
   implicit none
   integer :: il_max
 
   il_max = 0
 
   il_max = il_max + 1
   if_ppalm_ppexp_nb_time_0 = il_max
 
end function if_ppalm_ppexp_nb_time_0

integer function if_ppalm_ppsexp_time_0_1(id_z_srctgt,id_z_cpt,id_z_in,id_z_nb,ida_z_list,id_z_nbtot,id_z_list_size)
!  evaluate PL_NO_TIME 
!  id_z_srctgt = IP_SRC appel cote source , IP_TGT cote tgt
!  id_z_cpt : numero a partir duquel on compte (permet de traiter plusieurs sequences
!  id_z_in  : temps ou tag recherche
!  id_z_nb  : nombre d'element trouve
!  ida_z_list : en sortie : numero d'ordre des elements trouves
!  id_z_nbtot : en sortie : nombre total d'elements valide pour l'expression
!  
!  en sortie, la fonction vaut -1 si aucun element trouve
!  
 
   use gen_palmdef_f
   use palm_user_param
!  
   implicit none
!  
   integer, intent(in)    :: id_z_srctgt,id_z_in,id_z_list_size
   integer, intent(inout) :: id_z_cpt
   integer, intent(out)   :: id_z_nb,ida_z_list(*),id_z_nbtot
 
   integer :: il_dum
   if_ppalm_ppsexp_time_0_1 = -1 
   id_z_nb = 0 
   il_dum = id_z_srctgt 
 

   if(id_z_in.eq.PL_NO_TIME) then
       id_z_nb  = id_z_nb + 1
       if (id_z_nb.le.id_z_list_size) ida_z_list(id_z_nb) = id_z_cpt + 1
   endif 
   id_z_nbtot = 1
   if(id_z_nb.ne.0) if_ppalm_ppsexp_time_0_1 = ida_z_list(1)
end function if_ppalm_ppsexp_time_0_1
 
integer function if_ppalm_ppsexp_givetime_0_1(id_z_srctgt,id_z_in)
!  return the element'th in expression PL_NO_TIME 
 
   use gen_palmdef_f
   use palm_user_param
 
   implicit none
!  
   integer, intent(in)    :: id_z_srctgt,id_z_in
 
 
if_ppalm_ppsexp_givetime_0_1 = PL_NO_TIME
 
end function if_ppalm_ppsexp_givetime_0_1
 
 
integer function if_ppalm_ppexp_tag_0(id_z_srctgt,id_z_in,id_z_nb,ida_z_list,id_z_list_size)
!  
   use palm_user_param
!  
   implicit none
   integer, intent(in)    :: id_z_srctgt,id_z_in,id_z_list_size
   integer, intent(out)   :: id_z_nb,ida_z_list(*)
 
   integer :: il_z_nbtot,il_z_cpt,il_z_res,il_z_nb
!  
   integer if_ppalm_ppsexp_tag_0_1
   il_z_cpt = 0
   id_z_nb  = 0
   if_ppalm_ppexp_tag_0 = -1
  
   il_z_res = if_ppalm_ppsexp_tag_0_1(id_z_srctgt,il_z_cpt,id_z_in,il_z_nb,ida_z_list(id_z_nb+1),il_z_nbtot,id_z_list_size)
   il_z_cpt = il_z_cpt + il_z_nbtot
   id_z_nb  = id_z_nb + il_z_nb
   if (id_z_nb.ne.0) if_ppalm_ppexp_tag_0 = ida_z_list(1)
end function if_ppalm_ppexp_tag_0 
 
 
integer function if_ppalm_ppexp_give_tag_0(id_z_srctgt,id_num,id_val)
!  
   use palm_user_param
!  
   implicit none
   integer, intent(in)    :: id_z_srctgt,id_num
   integer, intent(out)   :: id_val
 
   integer :: il_z_nb,il_locnb
!  
   integer if_ppalm_ppsexp_givetag_0_1
   il_z_nb  = 0
   il_locnb  = 0
   if_ppalm_ppexp_give_tag_0 = -1
  
   il_z_nb = il_z_nb+1
   if (il_z_nb.ge.id_num) then 
     if_ppalm_ppexp_give_tag_0 = 1
     id_val = if_ppalm_ppsexp_givetag_0_1(id_z_srctgt,id_num-il_locnb)
     return
   endif 
   il_locnb = il_z_nb 
end function if_ppalm_ppexp_give_tag_0


 
integer function if_ppalm_ppexp_nb_tag_0()
   use palm_user_param
 
   implicit none
   integer :: il_max
 
   il_max = 0
 
   il_max = il_max + 1
   if_ppalm_ppexp_nb_tag_0 = il_max
 
end function if_ppalm_ppexp_nb_tag_0

integer function if_ppalm_ppsexp_tag_0_1(id_z_srctgt,id_z_cpt,id_z_in,id_z_nb,ida_z_list,id_z_nbtot,id_z_list_size)
!  evaluate PL_NO_TAG 
!  id_z_srctgt = IP_SRC appel cote source , IP_TGT cote tgt
!  id_z_cpt : numero a partir duquel on compte (permet de traiter plusieurs sequences
!  id_z_in  : temps ou tag recherche
!  id_z_nb  : nombre d'element trouve
!  ida_z_list : en sortie : numero d'ordre des elements trouves
!  id_z_nbtot : en sortie : nombre total d'elements valide pour l'expression
!  
!  en sortie, la fonction vaut -1 si aucun element trouve
!  
 
   use gen_palmdef_f
   use palm_user_param
!  
   implicit none
!  
   integer, intent(in)    :: id_z_srctgt,id_z_in,id_z_list_size
   integer, intent(inout) :: id_z_cpt
   integer, intent(out)   :: id_z_nb,ida_z_list(*),id_z_nbtot
 
   integer :: il_dum
   if_ppalm_ppsexp_tag_0_1 = -1 
   id_z_nb = 0 
   il_dum = id_z_srctgt 
 

   if(id_z_in.eq.PL_NO_TAG) then
       id_z_nb  = id_z_nb + 1
       if (id_z_nb.le.id_z_list_size) ida_z_list(id_z_nb) = id_z_cpt + 1
   endif 
   id_z_nbtot = 1
   if(id_z_nb.ne.0) if_ppalm_ppsexp_tag_0_1 = ida_z_list(1)
end function if_ppalm_ppsexp_tag_0_1
 
integer function if_ppalm_ppsexp_givetag_0_1(id_z_srctgt,id_z_in)
!  return the element'th in expression PL_NO_TAG 
 
   use gen_palmdef_f
   use palm_user_param
 
   implicit none
!  
   integer, intent(in)    :: id_z_srctgt,id_z_in
 
 
if_ppalm_ppsexp_givetag_0_1 = PL_NO_TAG
 
end function if_ppalm_ppsexp_givetag_0_1
 
integer function if_ppalm_timetag_search_0(id_z_srctgtflag,id_time,id_tag,id_z_nb,ida_z_list,id_z_list_size)
   implicit none
 
   integer, intent(in)    :: id_z_srctgtflag,id_time,id_tag,id_z_list_size
   integer, intent(inout) :: id_z_nb,ida_z_list(*)
 
!  automatic array (local) 
   integer, dimension(id_z_list_size) :: ila_timelist , ila_taglist
!  local variables
   integer :: il_z_nbtag , il_z_nbtime ,il_i, il_j, il_ij, il_z_nbtottag, il_tag
   integer :: if_ppalm_ppexp_tag_0, if_ppalm_ppexp_time_0
   integer :: if_ppalm_ppexp_nb_tag_0
 
   if_ppalm_timetag_search_0 = -1
 
   if (if_ppalm_ppexp_tag_0(id_z_srctgtflag,id_tag,il_z_nbtag,ila_taglist,id_z_list_size).eq.-1) return
   if (if_ppalm_ppexp_time_0(id_z_srctgtflag,id_time,il_z_nbtime,ila_timelist,id_z_list_size).eq.-1) return
 
   il_z_nbtottag = if_ppalm_ppexp_nb_tag_0()
   id_z_nb = il_z_nbtag * il_z_nbtime
 
   il_ij = 0
   do il_i = 1, il_z_nbtag
       il_tag = ila_taglist(il_i)
       do il_j = 1, il_z_nbtime
          il_ij = il_ij + 1
          if (il_ij.le.id_z_list_size)ida_z_list(il_ij) = il_tag + (ila_timelist(il_j) - 1) * il_z_nbtottag - 1
       enddo
   enddo
   if_ppalm_timetag_search_0 = ida_z_list(1)
end function if_ppalm_timetag_search_0


!==========================================================
integer function if_ppalm_give_timetag_0(id_z_srctgtflag,id_lcommid,id_time,id_tag)
   implicit none
 
!  arg
   integer, intent(in)    :: id_z_srctgtflag,id_lcommid 
   integer, intent(out)   :: id_time,id_tag
 
!  local variable 
   integer ::  il_z_nbtottag, il_numtag, il_numtime, il_err
   integer ::  if_ppalm_ppexp_nb_tag_0
   integer ::  if_ppalm_ppexp_give_time_0
   integer ::  if_ppalm_ppexp_give_tag_0
 
 
   if_ppalm_give_timetag_0 = -1
 
   il_z_nbtottag = if_ppalm_ppexp_nb_tag_0()
 
   il_numtime  = (id_lcommid) / il_z_nbtottag + 1
   il_numtag   = id_lcommid - (il_numtime-1) * il_z_nbtottag + 1
 
   il_err = if_ppalm_ppexp_give_time_0(id_z_srctgtflag,il_numtime,id_time)
   il_err = if_ppalm_ppexp_give_tag_0(id_z_srctgtflag,il_numtag,id_tag)
end function if_ppalm_give_timetag_0


!***************************************************************
!          END time & tag functions
!***************************************************************
integer function if_ppalm_in_localisation(cd_object, id_len, id_proc)
! =============================================================
! fonction de service pour les localisations des objets
! cd_object : nom de l'objet suffixe par l'unite 
! id_len    : longueur de la chaine cd_object pour compatibilit√© C  
! id_proc   : numero du proc dans la liste des proc de l'unite 
! 
! retourne 0 si le proc n''est pas dans la localisation
!          1 si le proc est dans la localisation
! 
! =============================================================
   use gen_palmdef_f
   use palm_user_param
!  
   implicit none
!  
   character(len=PL_LNAME), intent(in) :: cd_object
   integer, intent(in) :: id_len, id_proc
   integer :: iloc_ixxfg
     if_ppalm_in_localisation = 0
     iloc_ixxfg = 0
!    cas par defaut pour les  SINGLE_ON_FIRST_PROC
     if(id_proc.eq.0) if_ppalm_in_localisation = 1
     return
end function if_ppalm_in_localisation


!***************************************************************
!          localisation functions
!***************************************************************
 
integer function if_ppalm_ppexp_src_0(id_z_srctgt,id_z_in,id_z_nb,ida_z_list,id_z_list_size,&
                                                 id_nbprocsrcinpalm,id_nbproctgtinpalm)
!  
   use palm_user_param
!  
   implicit none
   integer, intent(in)    :: id_nbprocsrcinpalm,id_nbproctgtinpalm
   integer, intent(in)    :: id_z_srctgt,id_z_in,id_z_list_size
   integer, intent(out)   :: id_z_nb,ida_z_list(*)
 
   integer :: il_z_nbtot,il_z_cpt,il_z_res,il_z_nb,il_compteur
!  
   integer if_ppalm_ppsexp_src_0_1
   il_compteur = 0
   il_z_cpt = 0
   if_ppalm_ppexp_src_0 = -1
  
   il_z_res = if_ppalm_ppsexp_src_0_1&
              (id_z_srctgt,il_z_cpt,id_z_in,il_z_nb,ida_z_list(il_compteur+1),il_z_nbtot,id_z_list_size,&
               id_nbprocsrcinpalm,id_nbproctgtinpalm)
   il_z_cpt = il_z_cpt + il_z_nbtot
   il_compteur = il_compteur + il_z_nb
   id_z_nb = il_compteur
   if (id_z_nb.ne.0) if_ppalm_ppexp_src_0 = ida_z_list(1)
end function if_ppalm_ppexp_src_0 
 
 
integer function if_ppalm_ppexp_give_src_0(id_z_srctgt,id_num,id_val,id_nbprocsrcinpalm,&
                                                                                  id_nbproctgtinpalm)
!  
   use palm_user_param
!  
   implicit none
   integer, intent(in)    :: id_nbprocsrcinpalm,id_nbproctgtinpalm
   integer, intent(in)    :: id_z_srctgt,id_num
   integer, intent(out)   :: id_val
 
   integer :: il_z_nb,il_locnb
!  
   integer if_ppalm_ppsexp_givesrc_0_1
   il_z_nb  = 0
   il_locnb  = 0
   id_val  = 0
   if_ppalm_ppexp_give_src_0 = -1
  
   il_z_nb = il_z_nb+1
   if (il_z_nb.ge.id_num) then 
     if_ppalm_ppexp_give_src_0 = 1
     id_val = if_ppalm_ppsexp_givesrc_0_1(id_z_srctgt,id_num-il_locnb,id_nbprocsrcinpalm,&
                                                                             id_nbproctgtinpalm)
     return
   endif 
   il_locnb = il_z_nb 
end function if_ppalm_ppexp_give_src_0


 
integer function if_ppalm_ppexp_nb_src_0(id_nbprocsrcinpalm,id_nbproctgtinpalm)
   use palm_user_param
 
   implicit none
   integer,intent(in) :: id_nbprocsrcinpalm
   integer,intent(in) :: id_nbproctgtinpalm
   integer :: il_max
 
   il_max = 0
 
   il_max = il_max + 1
   if_ppalm_ppexp_nb_src_0 = il_max
 
end function if_ppalm_ppexp_nb_src_0

integer function if_ppalm_ppsexp_src_0_1(id_z_srctgt,id_z_cpt,id_z_in,id_z_nb,ida_z_list,id_z_nbtot,&
                                   id_z_list_size,id_nbprocsrcinpalm,id_nbproctgtinpalm)
!  evaluate 0 
!  id_z_srctgt = IP_SRC appel cote source , IP_TGT cote tgt
!  id_z_cpt : numero a partir duquel on compte (permet de traiter plusieurs sequences
!  id_z_in  : temps ou tag recherche
!  id_z_nb  : nombre d'element trouve
!  ida_z_list : en sortie : numero d'ordre des elements trouves
!  id_z_nbtot : en sortie : nombre total d'elements valide pour l'expression
!  
!  en sortie, la fonction vaut -1 si aucun element trouve
!  
 
   use gen_palmdef_f
   use palm_user_param
!  
   implicit none
!  
   integer, intent(in)    :: id_nbprocsrcinpalm,id_nbproctgtinpalm
   integer, intent(in)    :: id_z_srctgt,id_z_in,id_z_list_size
   integer, intent(inout) :: id_z_cpt
   integer, intent(out)   :: id_z_nb,ida_z_list(*),id_z_nbtot
 
   integer :: il_dum
   if_ppalm_ppsexp_src_0_1 = -1 
   id_z_nb = 0 
   il_dum = id_z_srctgt 
 

   if(id_z_in.eq.0) then
       id_z_nb  = id_z_nb + 1
       if (id_z_nb.le.id_z_list_size) ida_z_list(id_z_nb) = id_z_cpt + 1
   endif 
   id_z_nbtot = 1
   if(id_z_nb.ne.0) if_ppalm_ppsexp_src_0_1 = ida_z_list(1)
end function if_ppalm_ppsexp_src_0_1
 
integer function if_ppalm_ppsexp_givesrc_0_1(id_z_srctgt,id_z_in,id_nbprocsrcinpalm,id_nbproctgtinpalm)
!  return the element'th in expression 0 
 
   use gen_palmdef_f
   use palm_user_param
 
   implicit none
!  
   integer, intent(in)    :: id_nbprocsrcinpalm,id_nbproctgtinpalm
   integer, intent(in)    :: id_z_srctgt,id_z_in
 
 
if_ppalm_ppsexp_givesrc_0_1 = 0
 
end function if_ppalm_ppsexp_givesrc_0_1
 
 
integer function if_ppalm_ppexp_tgt_0(id_z_srctgt,id_z_in,id_z_nb,ida_z_list,id_z_list_size,&
                                                 id_nbprocsrcinpalm,id_nbproctgtinpalm)
!  
   use palm_user_param
!  
   implicit none
   integer, intent(in)    :: id_nbprocsrcinpalm,id_nbproctgtinpalm
   integer, intent(in)    :: id_z_srctgt,id_z_in,id_z_list_size
   integer, intent(out)   :: id_z_nb,ida_z_list(*)
 
   integer :: il_z_nbtot,il_z_cpt,il_z_res,il_z_nb,il_compteur
!  
   integer if_ppalm_ppsexp_tgt_0_1
   il_compteur = 0
   il_z_cpt = 0
   if_ppalm_ppexp_tgt_0 = -1
  
   il_z_res = if_ppalm_ppsexp_tgt_0_1&
              (id_z_srctgt,il_z_cpt,id_z_in,il_z_nb,ida_z_list(il_compteur+1),il_z_nbtot,id_z_list_size,&
               id_nbprocsrcinpalm,id_nbproctgtinpalm)
   il_z_cpt = il_z_cpt + il_z_nbtot
   il_compteur = il_compteur + il_z_nb
   id_z_nb = il_compteur
   if (id_z_nb.ne.0) if_ppalm_ppexp_tgt_0 = ida_z_list(1)
end function if_ppalm_ppexp_tgt_0 
 
 
integer function if_ppalm_ppexp_give_tgt_0(id_z_srctgt,id_num,id_val,id_nbprocsrcinpalm,&
                                                                                  id_nbproctgtinpalm)
!  
   use palm_user_param
!  
   implicit none
   integer, intent(in)    :: id_nbprocsrcinpalm,id_nbproctgtinpalm
   integer, intent(in)    :: id_z_srctgt,id_num
   integer, intent(out)   :: id_val
 
   integer :: il_z_nb,il_locnb
!  
   integer if_ppalm_ppsexp_givetgt_0_1
   il_z_nb  = 0
   il_locnb  = 0
   id_val  = 0
   if_ppalm_ppexp_give_tgt_0 = -1
  
   il_z_nb = il_z_nb+1
   if (il_z_nb.ge.id_num) then 
     if_ppalm_ppexp_give_tgt_0 = 1
     id_val = if_ppalm_ppsexp_givetgt_0_1(id_z_srctgt,id_num-il_locnb,id_nbprocsrcinpalm,&
                                                                             id_nbproctgtinpalm)
     return
   endif 
   il_locnb = il_z_nb 
end function if_ppalm_ppexp_give_tgt_0


 
integer function if_ppalm_ppexp_nb_tgt_0(id_nbprocsrcinpalm,id_nbproctgtinpalm)
   use palm_user_param
 
   implicit none
   integer,intent(in) :: id_nbprocsrcinpalm
   integer,intent(in) :: id_nbproctgtinpalm
   integer :: il_max
 
   il_max = 0
 
   il_max = il_max + 1
   if_ppalm_ppexp_nb_tgt_0 = il_max
 
end function if_ppalm_ppexp_nb_tgt_0

integer function if_ppalm_ppsexp_tgt_0_1(id_z_srctgt,id_z_cpt,id_z_in,id_z_nb,ida_z_list,id_z_nbtot,&
                                   id_z_list_size,id_nbprocsrcinpalm,id_nbproctgtinpalm)
!  evaluate 0 
!  id_z_srctgt = IP_SRC appel cote source , IP_TGT cote tgt
!  id_z_cpt : numero a partir duquel on compte (permet de traiter plusieurs sequences
!  id_z_in  : temps ou tag recherche
!  id_z_nb  : nombre d'element trouve
!  ida_z_list : en sortie : numero d'ordre des elements trouves
!  id_z_nbtot : en sortie : nombre total d'elements valide pour l'expression
!  
!  en sortie, la fonction vaut -1 si aucun element trouve
!  
 
   use gen_palmdef_f
   use palm_user_param
!  
   implicit none
!  
   integer, intent(in)    :: id_nbprocsrcinpalm,id_nbproctgtinpalm
   integer, intent(in)    :: id_z_srctgt,id_z_in,id_z_list_size
   integer, intent(inout) :: id_z_cpt
   integer, intent(out)   :: id_z_nb,ida_z_list(*),id_z_nbtot
 
   integer :: il_dum
   if_ppalm_ppsexp_tgt_0_1 = -1 
   id_z_nb = 0 
   il_dum = id_z_srctgt 
 

   if(id_z_in.eq.0) then
       id_z_nb  = id_z_nb + 1
       if (id_z_nb.le.id_z_list_size) ida_z_list(id_z_nb) = id_z_cpt + 1
   endif 
   id_z_nbtot = 1
   if(id_z_nb.ne.0) if_ppalm_ppsexp_tgt_0_1 = ida_z_list(1)
end function if_ppalm_ppsexp_tgt_0_1
 
integer function if_ppalm_ppsexp_givetgt_0_1(id_z_srctgt,id_z_in,id_nbprocsrcinpalm,id_nbproctgtinpalm)
!  return the element'th in expression 0 
 
   use gen_palmdef_f
   use palm_user_param
 
   implicit none
!  
   integer, intent(in)    :: id_nbprocsrcinpalm,id_nbproctgtinpalm
   integer, intent(in)    :: id_z_srctgt,id_z_in
 
 
if_ppalm_ppsexp_givetgt_0_1 = 0
 
end function if_ppalm_ppsexp_givetgt_0_1
 
 
integer function if_ppalm_ppexp_assoc_0(id_z_srctgt,id_z_in,id_z_nb,ida_z_list,id_z_list_size,&
                                                 id_nbprocsrcinpalm,id_nbproctgtinpalm)
!  
   use palm_user_param
!  
   implicit none
   integer, intent(in)    :: id_nbprocsrcinpalm,id_nbproctgtinpalm
   integer, intent(in)    :: id_z_srctgt,id_z_in,id_z_list_size
   integer, intent(out)   :: id_z_nb,ida_z_list(*)
 
   integer :: il_z_nbtot,il_z_cpt,il_z_res,il_z_nb,il_compteur
!  
   integer if_ppalm_ppsexp_assoc_0_1
   il_compteur = 0
   il_z_cpt = 0
   if_ppalm_ppexp_assoc_0 = -1
  
   il_z_res = if_ppalm_ppsexp_assoc_0_1&
              (id_z_srctgt,il_z_cpt,id_z_in,il_z_nb,ida_z_list(il_compteur+1),il_z_nbtot,id_z_list_size,&
               id_nbprocsrcinpalm,id_nbproctgtinpalm)
   il_z_cpt = il_z_cpt + il_z_nbtot
   il_compteur = il_compteur + il_z_nb
   id_z_nb = il_compteur
   if (id_z_nb.ne.0) if_ppalm_ppexp_assoc_0 = ida_z_list(1)
end function if_ppalm_ppexp_assoc_0 
 
 
integer function if_ppalm_ppexp_give_assoc_0(id_z_srctgt,id_num,id_val,id_nbprocsrcinpalm,&
                                                                                  id_nbproctgtinpalm)
!  
   use palm_user_param
!  
   implicit none
   integer, intent(in)    :: id_nbprocsrcinpalm,id_nbproctgtinpalm
   integer, intent(in)    :: id_z_srctgt,id_num
   integer, intent(out)   :: id_val
 
   integer :: il_z_nb,il_locnb
!  
   integer if_ppalm_ppsexp_giveassoc_0_1
   il_z_nb  = 0
   il_locnb  = 0
   id_val  = 0
   if_ppalm_ppexp_give_assoc_0 = -1
  
   il_z_nb = il_z_nb+1
   if (il_z_nb.ge.id_num) then 
     if_ppalm_ppexp_give_assoc_0 = 1
     id_val = if_ppalm_ppsexp_giveassoc_0_1(id_z_srctgt,id_num-il_locnb,id_nbprocsrcinpalm,&
                                                                             id_nbproctgtinpalm)
     return
   endif 
   il_locnb = il_z_nb 
end function if_ppalm_ppexp_give_assoc_0


 
integer function if_ppalm_ppexp_nb_assoc_0(id_nbprocsrcinpalm,id_nbproctgtinpalm)
   use palm_user_param
 
   implicit none
   integer,intent(in) :: id_nbprocsrcinpalm
   integer,intent(in) :: id_nbproctgtinpalm
   integer :: il_max
 
   il_max = 0
 
   il_max = il_max + 1
   if_ppalm_ppexp_nb_assoc_0 = il_max
 
end function if_ppalm_ppexp_nb_assoc_0

integer function if_ppalm_ppsexp_assoc_0_1(id_z_srctgt,id_z_cpt,id_z_in,id_z_nb,ida_z_list,id_z_nbtot,&
                                   id_z_list_size,id_nbprocsrcinpalm,id_nbproctgtinpalm)
!  evaluate 0 
!  id_z_srctgt = IP_SRC appel cote source , IP_TGT cote tgt
!  id_z_cpt : numero a partir duquel on compte (permet de traiter plusieurs sequences
!  id_z_in  : temps ou tag recherche
!  id_z_nb  : nombre d'element trouve
!  ida_z_list : en sortie : numero d'ordre des elements trouves
!  id_z_nbtot : en sortie : nombre total d'elements valide pour l'expression
!  
!  en sortie, la fonction vaut -1 si aucun element trouve
!  
 
   use gen_palmdef_f
   use palm_user_param
!  
   implicit none
!  
   integer, intent(in)    :: id_nbprocsrcinpalm,id_nbproctgtinpalm
   integer, intent(in)    :: id_z_srctgt,id_z_in,id_z_list_size
   integer, intent(inout) :: id_z_cpt
   integer, intent(out)   :: id_z_nb,ida_z_list(*),id_z_nbtot
 
   integer :: il_dum
   if_ppalm_ppsexp_assoc_0_1 = -1 
   id_z_nb = 0 
   il_dum = id_z_srctgt 
 

   if(id_z_in.eq.0) then
       id_z_nb  = id_z_nb + 1
       if (id_z_nb.le.id_z_list_size) ida_z_list(id_z_nb) = id_z_cpt + 1
   endif 
   id_z_nbtot = 1
   if(id_z_nb.ne.0) if_ppalm_ppsexp_assoc_0_1 = ida_z_list(1)
end function if_ppalm_ppsexp_assoc_0_1
 
integer function if_ppalm_ppsexp_giveassoc_0_1(id_z_srctgt,id_z_in,id_nbprocsrcinpalm,id_nbproctgtinpalm)
!  return the element'th in expression 0 
 
   use gen_palmdef_f
   use palm_user_param
 
   implicit none
!  
   integer, intent(in)    :: id_nbprocsrcinpalm,id_nbproctgtinpalm
   integer, intent(in)    :: id_z_srctgt,id_z_in
 
 
if_ppalm_ppsexp_giveassoc_0_1 = 0
 
end function if_ppalm_ppsexp_giveassoc_0_1
 
 
integer function if_ppalm_distype_0(id_srctgt)
! cette fonction retourne 1 pour distribue et 2 pour replique  
   use gen_palmdef_f
 
   implicit none
   integer, intent(in) :: id_srctgt
   if (id_srctgt.eq.IP_SRC) then
       if_ppalm_distype_0 = 2
   else 
       if_ppalm_distype_0 = 2
   endif
 
end function if_ppalm_distype_0 
 
integer function if_ppalm_assoc_nb(id_numfunc,id_nbprocsrcinpalm,id_nbproctgtinpalm)
!trigger qui retourne le nombre d'association
   implicit none
 
   integer, intent(in)    :: id_numfunc
   integer, intent(in)    :: id_nbprocsrcinpalm
   integer, intent(in)    :: id_nbproctgtinpalm
 
   integer if_ppalm_ppexp_nb_assoc_0
 
   if_ppalm_assoc_nb = -1
 
   select case (id_numfunc) 
       case (0)
            if_ppalm_assoc_nb = if_ppalm_ppexp_nb_assoc_0(id_nbprocsrcinpalm,id_nbproctgtinpalm)
            return
   end select
end function if_ppalm_assoc_nb


integer function if_ppalm_assoc_list(id_numfunc,id_numproc,id_side,id_nbprocsrcinpalm,&
                               id_nbproctgtinpalm,ida_assoclist,id_assoclist_size,id_assoc_nb)
!trigger qui retourne les numeros des associations
   implicit none
 
   integer, intent(in)    :: id_numfunc,id_numproc,id_side,id_assoclist_size
   integer, intent(in)    :: id_nbprocsrcinpalm
   integer, intent(in)    :: id_nbproctgtinpalm
   integer                :: ida_assoclist(id_assoclist_size) !out 
   integer                :: id_assoc_nb !out
   integer if_ppalm_assoc_list_0
   if_ppalm_assoc_list= -1
   select case (id_numfunc) 
       case (0)
            if_ppalm_assoc_list = if_ppalm_assoc_list_0(id_numproc,id_side,id_nbprocsrcinpalm,&
                                  id_nbproctgtinpalm,ida_assoclist,id_assoclist_size,id_assoc_nb)
            return
   end select
end function if_ppalm_assoc_list
integer function if_ppalm_assoc_loc(id_numfunc,id_numassoc,id_side,id_nbprocsrcinpalm,&
                                   id_nbproctgtinpalm,ida_listproc,id_listproc_size,id_proc_nb)
!trigger pour les fonctions qui retournent les proc des  d'association 
   implicit none
 
   integer, intent(in)    :: id_numfunc,id_numassoc,id_side,id_listproc_size
   integer, intent(in)    :: id_nbprocsrcinpalm
   integer, intent(in)    :: id_nbproctgtinpalm
   integer                :: ida_listproc(id_listproc_size) !out
   integer                :: id_proc_nb !out
   integer if_ppalm_assoc_loc_0
   if_ppalm_assoc_loc= -1
   select case (id_numfunc) 
       case (0)
            if_ppalm_assoc_loc = if_ppalm_assoc_loc_0(id_numassoc,id_side,id_nbprocsrcinpalm,&
                                         id_nbproctgtinpalm,ida_listproc,id_listproc_size,id_proc_nb)
            return
   end select
end function if_ppalm_assoc_loc


integer function if_ppalm_assoc_loc_0(id_numassoc,id_side,id_nbprocsrcinpalm,&
                                  id_nbproctgtinpalm,ida_listproc,id_listproc_size,id_proc_nb)
!fonction pour retourner les proc des associations 
   use gen_palmdef_f
 
   implicit none
 
   integer, intent(in)    :: id_numassoc,id_side,id_listproc_size
   integer, intent(in)    :: id_nbprocsrcinpalm
   integer, intent(in)    :: id_nbproctgtinpalm
   integer, intent(out)   :: ida_listproc(id_listproc_size)
   integer, intent(out)   :: id_proc_nb
   
   integer :: i_typedr,il_val,j,il_r
   integer :: if_ppalm_ppexp_give_assoc_0
   integer :: if_ppalm_ppexp_nb_src_0
   integer :: if_ppalm_ppexp_nb_tgt_0
   integer :: if_ppalm_ppexp_give_src_0
   integer :: if_ppalm_ppexp_give_tgt_0
   integer :: if_ppalm_distype_0
   
   if_ppalm_assoc_loc_0 = -1
   
   if (if_ppalm_ppexp_give_assoc_0(id_side,id_numassoc,il_val,id_nbprocsrcinpalm,id_nbproctgtinpalm)&
                                                                                              .eq. -1) then 
      id_proc_nb = 0
      return
   else 
   
!     type (2 replique ou 1 distr)    
      i_typedr = if_ppalm_distype_0(id_side)
      if (i_typedr .eq. 2) then
         id_proc_nb = 1
         ida_listproc(1) = il_val
         return
      else
         if (id_side.eq.IP_SRC) then
            id_proc_nb = if_ppalm_ppexp_nb_src_0(id_nbprocsrcinpalm,id_nbproctgtinpalm)
            do j = 1, id_proc_nb
               il_r = if_ppalm_ppexp_give_src_0(IP_SRC,j,il_val,id_nbprocsrcinpalm,id_nbproctgtinpalm)
               ida_listproc(j) = il_val
            enddo
         else 
            id_proc_nb = if_ppalm_ppexp_nb_tgt_0(id_nbprocsrcinpalm,id_nbproctgtinpalm)
            do j = 1, id_proc_nb
               il_r = if_ppalm_ppexp_give_tgt_0(IP_SRC,j,il_val,id_nbprocsrcinpalm,id_nbproctgtinpalm)
               ida_listproc(j) = il_val
            enddo
         endif
      endif
   endif
end function if_ppalm_assoc_loc_0


integer function if_ppalm_assoc_list_0(id_numproc,id_side,id_nbprocsrcinpalm,id_nbproctgtinpalm,&
                                            ida_assoclist,id_assoclist_size,id_assoc_nb)
!fonction pour retourner les listes d'association 
   use gen_palmdef_f
 
   implicit none
 
   integer, intent(in)    :: id_numproc,id_side,id_assoclist_size
   integer, intent(in)    :: id_nbprocsrcinpalm
   integer, intent(in)    :: id_nbproctgtinpalm
   integer, intent(out)   :: ida_assoclist(id_assoclist_size)
   integer, intent(out)   :: id_assoc_nb
  
  
   integer :: j, il_z_nb, i_typedr, il_proc
   integer :: ida_tab(1)
  
   integer :: if_ppalm_distype_0
   integer :: if_ppalm_ppexp_src_0
   integer :: if_ppalm_ppexp_tgt_0
   integer :: if_ppalm_ppexp_assoc_0
  
   if_ppalm_assoc_list_0= -1
   if (id_side.eq.IP_SRC) then
       
       if (if_ppalm_ppexp_src_0(IP_SRC,id_numproc,il_z_nb,ida_tab,1,&
                             id_nbprocsrcinpalm,id_nbproctgtinpalm) .eq. -1) then
           id_assoc_nb = 0
           return
       endif
       i_typedr = if_ppalm_distype_0(IP_SRC)
       if (i_typedr .eq. 1) then
          do j = id_nbprocsrcinpalm-1,0 , -1
           if (if_ppalm_ppexp_src_0(IP_SRC,j,id_assoc_nb,ida_assoclist,id_assoclist_size,&
                                        id_nbprocsrcinpalm,id_nbproctgtinpalm).ne.-1) il_proc = j
          enddo
       else
          il_proc =id_numproc
       endif
       if_ppalm_assoc_list_0= if_ppalm_ppexp_assoc_0(IP_SRC,il_proc,id_assoc_nb,&
                         ida_assoclist,id_assoclist_size,id_nbprocsrcinpalm,id_nbproctgtinpalm)
  
   else
       
       if (if_ppalm_ppexp_tgt_0(IP_SRC,id_numproc,il_z_nb,ida_tab,1,&
                         id_nbprocsrcinpalm,id_nbproctgtinpalm) .eq. -1) then
           id_assoc_nb = 0
           return
       endif
       i_typedr = if_ppalm_distype_0(IP_TGT)
       if (i_typedr .eq. 1) then
          do j = id_nbproctgtinpalm-1,0 , -1
           if (if_ppalm_ppexp_tgt_0(IP_SRC,j,id_assoc_nb,ida_assoclist,&
                     id_assoclist_size,id_nbprocsrcinpalm,id_nbproctgtinpalm).ne.-1) il_proc = j
          enddo
       else
          il_proc =id_numproc
       endif
       if_ppalm_assoc_list_0= if_ppalm_ppexp_assoc_0(IP_TGT,il_proc,id_assoc_nb,&
       ida_assoclist,id_assoclist_size,id_nbprocsrcinpalm,id_nbproctgtinpalm)
  
   endif
end function if_ppalm_assoc_list_0
!***************************************************************
!          END localisation functions
!***************************************************************
integer function if_ppalm_arg_script(id_branch,id_func,cd_argc,id_len)
!  branch trigger 
!
   implicit none
!
   integer :: id_branch, id_func, id_len
   character(LEN=256) :: cd_argc
!
   integer :: if_ppalm_arg_b0_script
   integer :: if_ppalm_arg_b1_script
!
   select case (id_branch) 
     case (0)
          if_ppalm_arg_script = if_ppalm_arg_b0_script(id_func,cd_argc,id_len)
          return
     case (1)
          if_ppalm_arg_script = if_ppalm_arg_b1_script(id_func,cd_argc,id_len)
          return
     case default
          if_ppalm_arg_script = 1
          return
   end select
end function if_ppalm_arg_script




integer function if_ppalm_arg_b0_script(id_func,cd_argc,id_len)
!
!**** if_ppalm_arg_b0_script : 
!
!     Purpose:
!     --------
!
!     File generated by PrePALM user: miguel 
!                               date: Tue Nov 15 16:39:03 CST 2016 
!     Don't edit this file!
!
!*--------------------------------------------------------------------------
!
 
   use m_ppalm_entities_b0
 
   implicit none
!
   integer :: id_func, id_len
   character(LEN=256) :: cd_argc
   logical :: ll_test
!
   character(LEN=300) :: cl_form
!  select the code to execute */
!
   if_ppalm_arg_b0_script = 0
   cd_argc = ''
!
   select case (id_func) 
     case default
        if_ppalm_arg_b0_script = 1
        return
   end select
end function if_ppalm_arg_b0_script




integer function if_ppalm_arg_b1_script(id_func,cd_argc,id_len)
!
!**** if_ppalm_arg_b1_script : 
!
!     Purpose:
!     --------
!
!     File generated by PrePALM user: miguel 
!                               date: Tue Nov 15 16:39:03 CST 2016 
!     Don't edit this file!
!
!*--------------------------------------------------------------------------
!
 
   use m_ppalm_entities_b1
 
   implicit none
!
   integer :: id_func, id_len
   character(LEN=256) :: cd_argc
   logical :: ll_test
!
   character(LEN=300) :: cl_form
!  select the code to execute */
!
   if_ppalm_arg_b1_script = 0
   cd_argc = ''
!
   select case (id_func) 
     case default
        if_ppalm_arg_b1_script = 1
        return
   end select
end function if_ppalm_arg_b1_script




integer function if_ppalm_branches_setget(id_branch,cd_name,id_len,id_val)
!
   use palmlib
!
   implicit none
!
   integer :: id_branch, id_val,id_len
   character(LEN=PL_LNAME) :: cd_name
   character(LEN=PL_LNAME) :: cl_name
!
   integer :: if_ppalm_b0_setget
   integer :: if_ppalm_b1_setget
!
   cl_name = cd_name(1:id_len)
   select case (id_branch) 
     case (0)
          if_ppalm_branches_setget = if_ppalm_b0_setget(cl_name,id_val)
          return
     case (1)
          if_ppalm_branches_setget = if_ppalm_b1_setget(cl_name,id_val)
          return
     case default
          if_ppalm_branches_setget = 0
          return
   end select
end function if_ppalm_branches_setget




integer function if_ppalm_b0_setget(cd_name,id_val)
 
   use palmlib
 
   implicit none
!
   integer :: id_val
   character(LEN=PL_LNAME) :: cd_name
!
!
!  select the intructions to execute */
!
   select case (cd_name) 

     case default
        if_ppalm_b0_setget = 0
        return

   end select

end function if_ppalm_b0_setget




integer function if_ppalm_b1_setget(cd_name,id_val)
 
   use palmlib
 
   implicit none
!
   integer :: id_val
   character(LEN=PL_LNAME) :: cd_name
!
!
!  select the intructions to execute */
!
   select case (cd_name) 

     case default
        if_ppalm_b1_setget = 0
        return

   end select

end function if_ppalm_b1_setget








subroutine palm_time_conv_init()
 
   use gen_palmdef_f
 
   implicit none
 
   integer :: il_time_step,il_year,il_month,il_day,il_hour
   integer :: il_min,il_sec,il_firsttime,il_calendar
 
   il_time_step = PL_TIME_DAY
   il_year      = 1950
   il_month     = 1
   il_day       = 1
   il_hour      = 0
   il_min       = 0
   il_sec       = 0
   il_firsttime = 0
   il_calendar  = PL_STANDARD_CALENDAR
 
   call palm_time_conv_set(il_time_step,il_year,il_month,il_day,il_hour,il_min,il_sec,il_firsttime,il_calendar)
 
end subroutine palm_time_conv_init







subroutine PALM_Setlistime(ida_obj,ida_listime,id_nb,id_err)
!
    use palmlib
!
    implicit none
!
 
    integer, intent(IN) :: id_nb
    integer, intent(OUT) :: id_err
    integer :: ida_listime(id_nb)
    character(LEN=PL_LNAME) :: ida_obj
 
    open(50,file=TRIM(ida_obj)//'.palm_listime',err=10)
    write(50,*) id_nb
    write(50,*) ida_listime
    close(50)
    id_err = 0
    return
 10 id_err = 32849
 
end subroutine PALM_setlistime
 
SUBROUTINE pl_ipr_updatevents
  IMPLICIT NONE
  RETURN
END SUBROUTINE pl_ipr_updatevents
!===================================================
! algebra modules ands subroutines                   
!===================================================
